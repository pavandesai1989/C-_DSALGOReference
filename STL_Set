/*  STL Set*/

1.std::set is an associative container and header that need to be include for it is,
#include<set>

2.Benefits and Features of std::set
a)It’s doesn’t allow duplicate elements i.e. it only contains unique elements.
b)Std::set can contain element of any specified type in template argument i.e.
c)std::set internally store elements in balanced binary tree.
d)By default std::set uses the operator < for comparing two elements and but if user passes the external sorting 
  criteria i.e. comparator then it uses that instead of default operator <.
e) std::set will keep the inserted elements in sorted order based on the assigned sorting criteria i.e. 
   either by default criteria operator < or by passed comparator (if passed)

/*********************set create and display******************************/
#include<iostream>
#include<set>
#include<string>
int main()
{
std::set<std::string> setOfNumbers;
// Lets insert four elements
setOfNumbers.insert("first");
setOfNumbers.insert("second");
setOfNumbers.insert("third");
setOfNumbers.insert("first");
// Only 3 elements will be inserted
std::cout<<"Set Size = "<<setOfNumbers.size()<<std::endl;
// Iterate through all the elements in a set and display the value.
for (std::set<std::string>::iterator it=setOfNumbers.begin(); it!=setOfNumbers.end(); ++it)
std::cout << ' ' << *it;
std::cout<<"\n";
return 0;
}

Output:
Set Size = 3
first second third

/******************How to search an element in std::set*********************************/
iterator find (const value_type& val) const;
It Searches the container for an element equivalent to val and returns an iterator to it 
if found, otherwise it returns an iterator to set::end.

#include<iostream>
#include<set>
#include<string>
int main()
{
std::set<std::string> setOfNumbers;
// Lets insert four elements
setOfNumbers.insert("first");
setOfNumbers.insert("second");
setOfNumbers.insert("third");
setOfNumbers.insert("first");
// Search for element in set using find member function
std::set<std::string>::iterator it = setOfNumbers.find("second");
if(it != setOfNumbers.end())
std::cout<<"'first'  found"<<std::endl;
else
std::cout<<"'first' not found"<<std::endl;
// Search for element in set using find member function
it = setOfNumbers.find("fourth");
if(it != setOfNumbers.end())
std::cout<<"'fourth'  found"<<std::endl;
else
std::cout<<"'fourth' not found"<<std::endl;
return 0;
}

Output:
‘first’ found
‘fourth’ not found

/***********************How to remove an element in std::set :***********************/
iterator  erase (const_iterator position);
size_type erase (const value_type& val);
iterator  erase (const_iterator first, const_iterator last);

/**********************C++ set for user define data type********************************/
#include<bits/stdc++.h> 
using namespace std; 
  
// Structure definition 
struct Test { 
    int id; 
      
    // This function is used by set to order 
    // elements of Test. 
    bool operator<(const Test& t) const
    { 
        return (this->id < t.id); 
    } 
}; 
  
// Driver method 
int main() 
{ 
    // put values in each  
    // structure define below. 
    Test t1 = { 110 }, t2 = { 102 },  
         t3 = { 101 }, t4 = { 115 }; 
  
    // define a set having  
    // structure as its elements. 
    set<struct Test> s;  
      
    // insert structure in set 
    s.insert(t1);  
    s.insert(t2); 
    s.insert(t3); 
    s.insert(t4); 
      
    // define an iterator to iterate the whole set. 
    set<struct Test>::iterator it;  
      
    for (it = s.begin(); it != s.end(); it++) 
    { 
        // print in ascending order as required. 
        cout << (*it).id << endl;  
    } 
      
    return 0; 
}


Accessing nth element using std::advance
// Iterator to the beginning of set
std::set<std::string>::iterator iter = setOfStr.begin();
// It will move forward the passed iterator by passed value
std::advance(iter, 3);
std::cout<<"3rd Element in set = "<<*iter<<std::endl;

Accessing nth element using std::next
It is introduced in c++11, unlike std::advance it doesn’t increment the given iterator, instead it returns a new iterator 
that will be n position advanced to given iterator.
Let’s see how to access the 3rd element using std::next,

// std::next internally iterate through n elements to reach
// nth element and returns the iterator of 3rd element in the set
std::set<std::string>::iterator it = std::next(setOfStr.begin(), 3);
std::cout<<"3rd Element in set = "<<*it<<std::endl;

/********************Inserting a Single element in Set and checking the result**********************************/
  Test t4(4);
  Test t1(1);
  Test t3(3);
  Test t2(2);

  set<Test> myset;
  myset.insert(t1);
  myset.insert(t2);
  myset.insert(t3);
  myset.insert(t4);

  pair<set<Test>::iterator,bool> result;
  result = myset.insert(2);

  if(result.second == false)
    cout<<"insertion failed "<<endl;
  else
    cout<<"Failed"<<endl;  
    
    //output insertion failed as we have already 2 in our set.!!!!!!!!!!!!!!!!!!!!!!!
    
  /********************************* Inserting an Iterator Range into a Set*******************************/
  std::vector<std::string> vecOfStrs = {"Hi", "Hello", "is", "the", "at", "Hi", "is"};
 
	std::set<std::string> setOfStrs;
 
	// Insert a Range in set
	// Range here is start and end iterators of a vector
	setOfStrs.insert(vecOfStrs.begin(), vecOfStrs.end());
  
  /**************Inserting a Initializer List in Set************************************/
  	std::set<std::string> setOfStrs;
 
	// Insert a Initializer list in the set
	setOfStrs.insert({"Hi", "Hello", "is", "the", "at", "Hi", "is"});
  
  
  
  /*************************set vs map**************************************/
a) Set :
Set is an associative container which we need to store unique elements.
It always keeps the elements in sorted order.
Internally it maintains a balanced binary search tree of elements. Therefore when we search an element inside the set 
then it takes only log(n) complexity to search it.

b) map:
Map:
Map is a associative container that is used to store key-value pair of elements with unique keys.
It always keeps the inserted pairs in sorted order based on the key.
Internally it maintains a balanced binary search tree to store keys. Therefore when searching key inside the map takes only
log(n) complexity.
We cannot modify the key of any inserted pair in map.
We can modify the value associated with a key in any inserted pair in map.

When to choose SET and when MAP?
So, if you want to maintain a data structure of unique keys only without any associated value that plan to modify in future then use set. If you want to modify any element in set then erase it and then insert the new one.
Whereas, use map if you want to maintain a data structure of unique keys and some associated value with each key that you want to change in future.









